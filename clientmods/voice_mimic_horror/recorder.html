<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  body { margin:0; background:transparent; overflow:hidden; }
  #s { position:fixed; top:2px; left:2px; font:10px monospace; color:#0f0; opacity:0.5; }
</style>
</head>
<body>
<div id="s">mic: init</div>
<script>
'use strict';
var VOL_THRESHOLD = 0.018;
var SILENCE_MS    = 1400;
var MIN_REC_MS    = 400;
var MAX_REC_MS    = 9000;
var mediaRecorder = null;
var analyser      = null;
var chunks        = [];
var isRecording   = false;
var recordStart   = 0;
var silenceStart  = 0;
var st = document.getElementById('s');

async function initMic() {
  try {
    var stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
      video: false
    });
    var ctx = new (window.AudioContext || window.webkitAudioContext)();
    var src = ctx.createMediaStreamSource(stream);
    analyser = ctx.createAnalyser();
    analyser.fftSize = 256;
    analyser.smoothingTimeConstant = 0.85;
    src.connect(analyser);
    var mimeTypes = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus'];
    var mimeType = mimeTypes.find(function(t){ return MediaRecorder.isTypeSupported(t); }) || '';
    mediaRecorder = new MediaRecorder(stream, mimeType ? {mimeType: mimeType} : {});
    mediaRecorder.ondataavailable = function(e){ if(e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = saveClip;
    st.textContent = 'mic: ready';
    window.luanti.send('ready','mic_ok');
    requestAnimationFrame(vad);
  } catch(e) {
    st.textContent = 'mic: ERR';
    window.luanti.send('error', String(e));
  }
}

function getRMS() {
  var data = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(data);
  var sum = 0;
  for(var i=0;i<data.length;i++) sum += (data[i]/255)*(data[i]/255);
  return Math.sqrt(sum/data.length);
}

function vad() {
  var vol = getRMS();
  var now = Date.now();
  if(vol > VOL_THRESHOLD) {
    silenceStart = 0;
    if(!isRecording) {
      isRecording = true; recordStart = now; chunks = [];
      try{ mediaRecorder.start(80); }catch(e){}
      st.textContent = 'mic: REC';
    } else if((now - recordStart) > MAX_REC_MS) {
      mediaRecorder.stop(); isRecording = false;
    }
  } else {
    if(isRecording) {
      if(!silenceStart) { silenceStart = now; }
      else if((now-silenceStart)>SILENCE_MS && (now-recordStart)>MIN_REC_MS) {
        mediaRecorder.stop(); isRecording = false; silenceStart = 0;
        st.textContent = 'mic: saving';
      }
    } else { st.textContent = 'mic: ok'; }
  }
  requestAnimationFrame(vad);
}

function saveClip() {
  if(!chunks.length) return;
  var blob = new Blob(chunks, {type: chunks[0].type||'audio/webm'});
  chunks = [];
  var reader = new FileReader();
  reader.onload = function() {
    window.luanti.send('voice_clip', reader.result.split(',')[1]);
    st.textContent = 'mic: saved';
  };
  reader.readAsDataURL(blob);
}

window.playClip = function(b64, pitch) {
  pitch = parseFloat(pitch) || 0.82;
  try {
    var bin = atob(b64);
    var arr = new Uint8Array(bin.length);
    for(var i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
    var blob = new Blob([arr],{type:'audio/webm'});
    var url = URL.createObjectURL(blob);
    var audio = new Audio(url);
    audio.playbackRate = pitch;
    audio.volume = 1.0;
    audio.play().then(function() {
      st.textContent = 'MIMICKING...';
      audio.onended = function() {
        URL.revokeObjectURL(url);
        window.luanti.send('played','');
        st.textContent = 'mic: ok';
      };
    }).catch(function(err) {
      URL.revokeObjectURL(url);
      window.luanti.send('play_error',String(err));
    });
  } catch(e) { window.luanti.send('play_error',String(e)); }
};

window.addEventListener('load', initMic);
</script>
</body>
</html>
